// Generated by CoffeeScript 1.12.4
var Button, ButtonMixin, ImageView, Responder, Style, TapResponder, TextView, View, mergeDefaults, modx, parseOptions;

Responder = require("gesture").Responder;

Style = require("react-validators").Style;

mergeDefaults = require("mergeDefaults");

TapResponder = require("TapResponder");

parseOptions = require("parseOptions");

ImageView = require("modx/lib/ImageView");

TextView = require("modx/lib/TextView");

View = require("modx/lib/View");

modx = require("modx");

ButtonMixin = require("./ButtonMixin");

Button = (function() {
  var type;
  type = modx.Component("Button");
  type.addMixin(ButtonMixin);
  type.inheritProps(View, {
    exclude: Responder.eventNames
  });
  type.defineProps({
    icon: Object,
    iconStyle: Style,
    text: String,
    textStyle: Style,
    onTap: Function,
    onReject: Function,
    onGrant: Function,
    onRelease: Function,
    onTouchStart: Function,
    onTouchMove: Function,
    onTouchEnd: Function
  });
  type.defineProps((function() {
    var propTypes;
    propTypes = {};
    [TapResponder, Responder].forEach(function(type) {
      return mergeDefaults(propTypes, type.optionTypes);
    });
    return propTypes;
  })());
  type.defineValues({
    _tap: function() {
      var options;
      options = parseOptions(TapResponder, this.props);
      return TapResponder(options);
    }
  });
  type.defineListeners((function() {
    var eventMap;
    eventMap = {
      didReject: "onReject",
      didGrant: "onGrant",
      didRelease: "onRelease",
      didTap: "onTap",
      didTouchStart: "onTouchStart",
      didTouchMove: "onTouchMove",
      didTouchEnd: "onTouchEnd"
    };
    return function() {
      var _tap, callback, eventKey, propKey, props, ref;
      ref = this, props = ref.props, _tap = ref._tap;
      for (eventKey in eventMap) {
        propKey = eventMap[eventKey];
        if (callback = props[propKey]) {
          _tap[eventKey](callback);
        }
      }
    };
  })());
  type.defineMethods({
    __renderIcon: function() {
      var icon, iconStyle, ref;
      ref = this.props, icon = ref.icon, iconStyle = ref.iconStyle;
      if (icon) {
        return ImageView({
          style: iconStyle,
          source: icon
        });
      } else {
        return null;
      }
    },
    __renderText: function() {
      var ref, text, textStyle;
      ref = this.props, text = ref.text, textStyle = ref.textStyle;
      if (text) {
        return TextView({
          style: textStyle,
          text: text
        });
      } else {
        return null;
      }
    }
  });
  return type.build();
})();

Button.Type = (function() {
  var type;
  type = modx.Type("Button");
  type.addMixin(ButtonMixin);
  type.defineArgs(function() {
    return {
      defaults: {
        maxTapCount: 1
      },
      types: {
        icon: Object,
        text: String,
        maxTapCount: Number,
        preventDistance: Number
      }
    };
  });
  type.defineValues({
    _icon: function(options) {
      return options.icon;
    },
    _text: function(options) {
      return options.text;
    },
    _tap: function(options) {
      var tapOptions;
      tapOptions = parseOptions(TapResponder, options);
      return TapResponder(tapOptions);
    }
  });
  type.defineStyles({
    icon: null,
    text: null
  });
  type.defineMethods({
    __renderIcon: function() {
      if (this._icon) {
        return ImageView({
          source: this._icon,
          style: this.styles.icon()
        });
      } else {
        return null;
      }
    },
    __renderText: function() {
      if (this._text) {
        return TextView({
          text: this._text,
          style: this.styles.text()
        });
      } else {
        return null;
      }
    }
  });
  type.defineGetters({
    didTap: function() {
      return this._tap.didTap.listenable;
    },
    didReject: function() {
      return this._tap.didReject.listenable;
    },
    didGrant: function() {
      return this._tap.didGrant.listenable;
    },
    didEnd: function() {
      return this._tap.didEnd.listenable;
    },
    didTouchStart: function() {
      return this._tap.didTouchStart.listenable;
    },
    didTouchMove: function() {
      return this._tap.didTouchMove.listenable;
    },
    didTouchEnd: function() {
      return this._tap.didTouchEnd.listenable;
    }
  });
  return type.build();
})();

module.exports = Button;
